<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>Planning Map</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="pathfinding-browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    body, html, #map { margin:0; padding:0; width:100%; height:100%; }
    #info {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.85);
    padding: 8px 12px;
    font-size: 25px;  
    font-weight: bold;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    z-index: 1;
  }
  </style>
</head>
<body>
<div id="map"></div>
<div id="info"></div>
<script>
mapboxgl.accessToken = 'pk.eyJ1IjoibGVrYW5ndHUiLCJhIjoiY21jMjA0OG5pMDM0dzJucHF6bDMzbmN0NyJ9.i3abVxeRE87ojHWRwm7-bg';

// —— Custom bounding box and grid settings ——
// const BBOX   = { west:-76.940002, south:38.989303, east:-76.937256, north:38.991437 };  38.989303,-76.940002   38.991437,-76.937256
const BBOX   = { west:-76.954610, south:38.978949, east:-76.934513, north:38.999111}
// const GRID_W = 1024, GRID_H = 1024;
const GRID_W = 8704, GRID_H = 11264;
const SAFETY = 0;       // Expansion radius (cells) for walkability

// ----- Coordinate conversion: lon/lat <-> grid -----
function lngLatToGrid(lng,lat){
  // Convert longitude/latitude to grid cell indices
  const u=(lng-BBOX.west)/(BBOX.east-BBOX.west),
        v=(BBOX.north-lat)/(BBOX.north-BBOX.south);
  return [
    Math.min(GRID_W-1, Math.max(0, Math.floor(u*GRID_W))),
    Math.min(GRID_H-1, Math.max(0, Math.floor(v*GRID_H)))
  ];
}
function gridToLngLat(x,y){
  // Convert grid cell indices to longitude/latitude (cell center)
  const lng=BBOX.west + (x+0.5)/GRID_W*(BBOX.east-BBOX.west),
        lat=BBOX.north - (y+0.5)/GRID_H*(BBOX.north-BBOX.south);
  return [lng,lat];
}

let maskGrid, grid, finder;

// ---- Load binary mask grid (JSON), then expand safety margin ----
// fetch('new_mask_grid1024.json')
fetch('fixed_campus_map.json')
  .then(r=>r.ok?r.json():Promise.reject(r.status))
  .then(json=>{
    // Invert mask & apply expansion
    const H=json.length, W=json[0].length;
    const raw = json.map(r=>r.map(v=>v?0:1));          // 0=walkable, 1=blocked
    const dil = Array(H).fill(0).map(_=>Array(W).fill(1));
    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        if(raw[y][x]!==0) continue;
        let ok=true;
        out:
        for(let dy=-SAFETY;dy<=SAFETY;dy++){
          const yy=y+dy; if(yy<0||yy>=H){ ok=false; break; }
          for(let dx=-SAFETY;dx<=SAFETY;dx++){
            const xx=x+dx; if(xx<0||xx>=W){ ok=false; break out; }
            if(raw[yy][xx]===1){ ok=false; break out; }
          }
        }
        if(ok) dil[y][x]=0; // Only mark as walkable if surrounded by walkable area
      }
    }
    maskGrid = dil;
    grid     = new PF.Grid(maskGrid);
    finder   = new PF.AStarFinder({allowDiagonal:true,dontCrossCorners:true});
    console.log('Mask grid after dilation:',H,'×',W);

    // Visualize walkable area as polygons on the map
    const feats=[];
    for(let y=0;y<GRID_H;y++){
      for(let x=0;x<GRID_W;x++){
        if(maskGrid[y][x]!==0) continue;
        const [lng1,lat1]=gridToLngLat(x,y),
              [lng2,lat2]=gridToLngLat(x+1,y+1);
        feats.push({
          type:'Feature',
          geometry:{
            type:'Polygon',
            coordinates:[[ [lng1,lat1],[lng2,lat1],[lng2,lat2],[lng1,lat2],[lng1,lat1] ]]
          }
        });
      }
    }
    map.addSource('walkable',{type:'geojson',data:{type:'FeatureCollection',features:feats}});
    map.addLayer({
      id:'walkable',type:'fill',source:'walkable',
      paint:{'fill-color':'#ff00ff','fill-opacity':0.3}
    });
  })
  .catch(err=>console.error(err));

// ---- Initialize Mapbox GL map ----
const map = new mapboxgl.Map({
  container:'map',
  style:'mapbox://styles/mapbox/satellite-streets-v11',
  center:[-76.9375,38.9900],
  zoom:18
});

// ---- Click-to-select waypoints ----
let pts=[];
map.on('click', e=>{
  if(!maskGrid){ alert('Mask not loaded yet'); return; }
  pts.push(e.lngLat);
  new mapboxgl.Marker().setLngLat(e.lngLat).addTo(map);
  if(pts.length===2){
    computeAndDraw(pts[0],pts[1]);
    pts=[];
  }
});

// ---- Main: pathfinding, simplification, drawing, export ----
async function computeAndDraw(a, b) {
  // 1. Use A* to get grid path, convert to lon/lat coordinates
  const [sx, sy] = lngLatToGrid(a.lng, a.lat),
        [ex, ey] = lngLatToGrid(b.lng, b.lat),
        rawPath   = finder.findPath(sx, sy, ex, ey, grid.clone());
  const coords = rawPath.map(([x,y]) => gridToLngLat(x,y));

  // 2. Build Turf.js LineString and measure route length (in miles)
  const line     = turf.lineString(coords);
  const lengthMi = turf.length(line, { units: 'miles' });

  // 3. Dynamically set sampling interval to ensure at least MIN_POINTS
  const MIN_POINTS  = 10;       // Minimum number of output points
  const BASE_INT    = 0.002;    // Default interval in miles (~3m)
  let intervalMi    = BASE_INT;
  const estCount    = Math.floor(lengthMi / BASE_INT) + 1;
  if (estCount < MIN_POINTS) {
    // If too short, reduce interval to fill up to MIN_POINTS
    intervalMi = lengthMi / (MIN_POINTS - 1);
  }

  // 4. Sample points along the route at fixed intervals
  const sampled = [];
  for (let dist = 0; dist <= lengthMi; dist += intervalMi) {
    const pt = turf.along(line, dist, { units: 'miles' });
    sampled.push(pt.geometry.coordinates);
  }
  // Ensure the very last point is included
  const last = coords[coords.length - 1];
  if (!turf.booleanEqual(turf.point(sampled[sampled.length - 1]), turf.point(last))) {
    sampled.push(last);
  }

  console.log(`Total ${lengthMi.toFixed(3)} mi, sampled ${sampled.length} pts (interval ${intervalMi.toFixed(4)} mi)`);

  // 5. Draw sampled route on the map (as red line)
  const routeGeo = {
    type: 'Feature',
    geometry: { type:'LineString', coordinates: sampled }
  };
  if (map.getSource('route')) {
    map.getSource('route').setData(routeGeo);
  } else {
    map.addSource('route',{ type:'geojson', data: routeGeo });
    map.addLayer({
      id:'route', type:'line', source:'route',
      paint:{ 'line-color':'#ff0000','line-width':4 }
    });
  }

  // 6. Export the route as a TXT file (comma-separated coordinates)
  const txt = sampled.map(p => p.join(',')).join('\n');
  const blob = new Blob([txt], { type:'text/plain' });
  const url  = URL.createObjectURL(blob);
  const aTag = document.createElement('a');
  const info = document.getElementById('info');
  info.innerText = `Distance ${lengthMi.toFixed(3)} mi, sampled ${sampled.length} pts (interval ${intervalMi.toFixed(3)} mi)`;
  aTag.href     = url;
  aTag.download = 'path.txt';
  document.body.appendChild(aTag);
  aTag.click();
  document.body.removeChild(aTag);
  URL.revokeObjectURL(url);
}



</script>
</body>
</html>
